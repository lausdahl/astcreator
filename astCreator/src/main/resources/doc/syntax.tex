\lstnewenvironment{astlst}{\lstset{basicstyle=\footnotesize\ttfamily}}
{}



\section{Syntax}

The syntax is divided into a number of sections:

\begin{description}

\item[\textbf{\texttt{Packages}}] This section allowed the default packages to be defined for \texttt{base} and \texttt{analysis}:

\begin{astlst}
base org.overture.ast.node;
analysis org.overture.ast.analysis;
\end{astlst}

\item[\textbf{\texttt{Tokens}}] This section defined tokens as tokens coming from a parser which uses the \texttt{Token} or external field types either as:
\begin{itemize}
\item \textbf{Standard Java Types} such as \texttt{Integer, Boolean, Long, Char, ...}
\item \textbf{External classes} where the interface \texttt{ExternalNode} is implemented. This provides the AST which the ability to clone the node.
\item \textbf{External defined Node} where such a node extends \texttt{Node} like any other node of the tree. Implementing all analysis and enumerations according to the tree standard.
\item \textbf{External enum} This is like the standard Java type where the type given is a Java \texttt{enum}.
\end{itemize}

\begin{astlst}
bool = 'bool';
java_Integer = 'java:java.lang.Integer';

location = 'java:org.overturetool.vdmj.lex.LexLocation';
LexToken = 'java:node:org.overturetool.vdmj.lex.LexToken';
nameScope = 'java:enum:org.overturetool.vdmj.typechecker.NameScope';
\end{astlst}

\item[\textbf{\texttt{Abstract Syntax Tree}}] This section describes the actual tree. Names at the top level are considered roots and \# are considered sub roots and must be both specified as a root and a child of one or the main roots like \texttt{exp} in this case. Fields can be specified using \[ \] where the name is giving between the brackets and the type after the colon. A field can also be specified with ( ) which creates a field in the same style but it will not have its parent set when added, this is called a graph field. For the type naming see section~\ref{}.


\begin{astlst}
exp {-> package='org.overture.ast.expressions'}
    =   {apply} [root]:exp [args]:exp* [argtypes]:type* (recursive):definition
    |   #Unary
    ;

#Unary {-> package='org.overture.ast.expressions'}
    =   {absolute} 
    |   {head} 
    |   {mapInverse} (mapType):type.#Map
    ;
\end{astlst}

The above example will generate a tree like:

\begin{figure}[htb]
\texttt{
\Tree[.exp apply [.\#Unary absolute head mapInverse ] ]}
\caption{AST Example.}
\end{figure}

\begin{figure}[htb]
\texttt{
\Tree[.apply root args argtypes recursive ]}
\caption{Field example for \texttt{apply}.}
\end{figure}


\begin{figure}[htb]
\texttt{
\Tree[.mapInverse mapType ]}
\caption{Field example for \texttt{mapInverse}.}
\end{figure}

\begin{figure}[htb]
\texttt{
\Tree[.PExp AApplyExp [.SUnaryExp AAbsoluteUnaryExp AHeadUnaryExp AMapInverseUnaryExp ] ]}
\caption{AST Example with generated names.}
\end{figure}

\item[\textbf{\texttt{Aspect Declaration}}] hj


\begin{astlst}
%exp = [type]:type [location]:location
    ;
\end{astlst}


\end{description}

\subsection{Hierarchy}

\subsection{Referencing}